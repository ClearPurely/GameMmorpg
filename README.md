# 这是一个MMRPG的项目

以下是对各个系统部分的解释，记录我的开发过程



## 项目相关问题

1、实现角色预览显示在UI上，用一个摄像机对着角色，然后绑定摄像机的TargetTexture属性，创建一个RenderTexture，把他绑定在摄像机上实现投影，再绑定到一个RawImage上面，把这个RawImage显示到场景中就可以实现角色预览

RawImage和Image的不同就在于Rawimage本质上取得就是这个资源的Texture，其他的属性它都不关心。

2.小地图的映射



# 基础系统

#### 角色怎样进入主城

1. 点击进入游戏后，客户端向服务器发送当前角色进入主城的请求
2. 服务器的UserService接收到请求后
   1. 服务器的UserService进行数据检验（防止外挂）
   2. UserService 将此角色的数据初始化，数据包括，坐标、方向、速度、哪张地图等，通过协议工具进行封装，发送到客户端
      1. 由于Uservice关心的是单个角色的请求与响应，所以需要另外的Service来执行地图中所有角色对于地图中新添加的角色的响应（包括当前要进入地图中的角色）
      2. 2.2结束之后，通过MapService向当前角色所进入的地图中的所有角色发送消息，有新的角色进入当前地图了
3. 客户端接收到UserService的反应消息（2.0 response）并不做任何反应， （我们关心的是服务器MapService的消息）
4. 客户端接收到服务器MapService的消息后，加载地图数据、实例化所有当前地图的角色（包括自己）、并且把一些必要的组件添加到当前的角色中。

#### 世界空间UI

https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/HOWTO-UIWorldSpace.html

世界原素管理器（UIWorldElementManager）

保存所有UI系统的节点

进入场景，角色要初始化自己相关的信息，相机的位置，以及一个实体控制器（EntityController）

#### 小地图

通过保持小地图的中心点始终与用户相对于地图场景的位置重叠来让小地图图片在mask组件中居中。



#### 移动同步

状态同步
帧同步

**不执行被碰撞对象的OnTriggerEnter()碰撞函数的可能原因：Unity设置里碰撞层级没有设置**
Edit->Project Settings->Phyics；一般来说是Default没有勾选。

用一个角色管理器（CharaceterManager）保存所有角色信息，然后用地图服务（MapService）管理每张地图里面的角色管理器，每次有角色进出就会对周围的角色进行广播。

#### 地图传送

- 添加了一个在unity界面可用地图工具。

服务器端设计一个地图管理器，用于处理玩家进出的业务，而客户端只用关注当前地图的情况，所以用一个小地图管理器来显示地图



#### UI框架



#### Npc系统

用一个manager来管理所有的npc，然后每个npc的具体行为都通过一个NPC控制器（NPCController）来管理，比如朝向玩家、点击会出现对话等业务逻辑。

npc可以设置类型，这样可以拓展出多种不同的npc，例如任务、商店以及副本



#### 背包系统

必须包含道具系统，用字典来保存道具和数量。用结构体保存所有的道具列表，再用字符指针数组指向道具列表，存储到数据库时反序列化，通过指针指向的道具把相应的数量保存到内存中，每隔一段时间保存到数据库中。

道具种类过多，采用二进制数据存储。

服务器只需要有serviece，客户端有manager和service，实现背包的业务功能和收发信息，服务器只需要收发用户背包信息的改变。

添加道具，将道具的素材路径存到配置表中，运行时加载。



#### 商店系统

商店分为商店类型和功能，这样便于拓展出多种不同种类的商店。

购买功能要传入用户的信息，这是和背包系统中物品管理器的不同。

引入状态系统来解决服务端收一个协议返回三个协议的情况。状态系统可以定义多种不同的物品的变化（武器、道具），用一个结构来表示游戏内所有可能发生的变化，定义一个状态通知





#### 装备系统

可以将装备也归属于道具类的一部分，在玩家装备的界面只会将该玩家职业能穿戴的装备，并且这个道具类型是装备的道具显示，点击穿戴装备后，把装备的id发到服务器进行处理，判断这个装备是否已被穿戴、玩家是否拥有这件装备（防外挂），再进行穿戴。

玩家穿戴的装备的信息用二进制数据存储。



#### 任务系统

防外挂：客户端和服务器同时记录，提交任务时校验一次。
已接受的任务状态分为四种，不同职业的任务奖励不同，可以把一个任务分成多个任务（列拓展转换为行拓展）。

前置任务和后置任务，不设置后置任务，只设置后置任务。可以达成一个任务有多个前置的效果

目标的类型

进入地图，初始化任务管理器，每个npc都会初始化对应状态，



#### 刷怪系统

服务器有管理器，刷怪是地图管理器的一部分，可以类比玩家进入地图的过程，因此只需要在服务器实现逻辑就行。

刷怪分为规则和刷新位置

一张刷怪规则表定义等级、刷新周期，另一张刷怪地点表表示在地图中的具体位置和数量等



#### 好友系统

 [好友系统交互流程图.pdf](source\好友系统交互流程图.pdf) 

分为离线和在线添加好友。离线添加好友时需要把请求的信息存储在数据库中



#### 组队系统

组队系统不依赖数据库，我们可以直接在内存中分配可以存储5个人组队的数据结构，用来保存组队信息，每次加入退出直接操作这个数据结构即可。

服务器和客户端需要双向通信。

加入队伍判断是否有队伍，离开队伍时判断是否是队长

#### 公会系统

创建、解散、转让、任命（升职和撤职）、逐出、搜索成员、离开公会时判断是不是会长、不同的职位的权限管理

还有处理离线时玩家加入公会的请求，



#### 聊天系统

右键玩家姓名可以弹出添加好友、私聊和邀请组队的功能选项。

可以用超文本连接的聊天栏插件实现对话框，设置不同的通道来显示接收来自不同通道的消息，这样达到有多频道聊天的效果



# 战斗系统

角色属性设计

升级一般都是一级一级的升，可以触发等级事件



## 技能释放流程：

- 释放的条件
  - 目标
  - MP消耗
  - CD
  - 施法时间和技能类型
    - 瞬发
    - 持续时间
    - 技能次数
  - 范围
- 释放技能
  - 类型
    - AOE
    - 范围
    - 持续时间和间隔

  - 行为
    - 伤害：公式、数值
    - BUFF

  - 表现
    - 名称
    - 图标
    - 特效

- 广播技能的命中信息（服务器端）
  - 每帧合并所有技能的命中信息，减少信息数量，在一帧内一次性释放技能列表的所有技能。
  - 信息包含
    - 伤害来源
    - 技能信息
    - 命中次数，索引
    - 伤害信息：目标、数值、暴击信息



范围选择类型技能：

使用投射器Projecter，默认下没有提供，需要在商店去下载



## buff系统的流程：

buff的添加在技能判断释放成功之后添加，用一个列表保存一个游戏对象的所有buff
客户端和服务端的区别是是否需要创建和发送网络信息，客户端不需要，但是需要有UI方面的表现
造成伤害时在服务端进行判断，直接发送造成伤害的信息就行，这样更安全



## 技能特效和世界元素公用特效

如果是技能上绑定的特效：就先在角色的预制体上用一个节点保存所有特效的预制体，然后用一个管理器来管理，在角色的动画上添加事件元素，把对应的特效绑定在事件元素上就可以在动画播放时播放特效。
如果一个特效被多个实体所用到，可以在世界关卡中添加一个单例节点用一个特效管理器(TXManager)保存所有的特效，在需要播放这些特效的地方通过特效管理器(TXManager)来播放。
飘字用一个插件LeanTween实现



## 竞技场和副本




客户端：



服务端：

一个map只能对应一个battle，一对一的关系可以交叉引用



# 优化



## AOI

**地图消息同步范围**

兴趣范围 广播范围
全服、地图、社交、交互、自身

100人	每秒10次同步	每秒100000次消息处理  (包转换率)		=		3M/s(网速)	24M/s(带宽)

减少信息发送的数量和频率





















